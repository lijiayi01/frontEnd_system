# 生产级别项目的表设计

## 1. 表设计规范

### 1. 命名规范
- 表名建议使用模块_+功能点的格式，比如live_log,不管是表名设计还是字段名设计，都使用小写命名，中间使用_连接，不允许出现大写驼峰的命名方式。
- 数据库对象名全部使用小写字母加_格式，比如user_name
- 数据库对象名禁止使用mysql保留字
- 最好不要超过32个字符
- 临时表必须tmp为前缀并以日期为后缀
- 备份表必须以bak为前缀并以日期为后缀
- 所有存储相同数据的列名和列类型必须相同

### 2. 数据库设计规范

- 所有表必须使用Innodb存储引擎(5.6以后默认的引擎)
- 数据库和表的字符集统一使用utf8(要统一字符集)
- 所有的表和字段都需要添加注释(comment从句来添加)
- 尽量控制单表数据量的大小，建议控制在500w以内(历史数据分档 分库分表)
- 谨慎使用mysql分区表
- 尽量做到冷热数据分离，减少表的宽度（也就是列的数量），mysql最多能存4096列
- 禁止在表中建立预留字段(***)
- 禁止在数据库中存储图片 文件等二进制数据
- 禁止在线上做数据库压力测试
- 禁止从开发 测试环境直接连接生产环境数据库

### 3. 索引设计规范

- 限制每张表的索引数量，建议单张表索引数量不超过5个
- 每张表必须有一个主键
    - 不使用更新频繁的列作为索引，不使用多列主键
    - 使用uuid md5 hash 字符串列作为主键
    - 建议使用自增id 
- 常见索引列建议
    - select update delete语句的where从句中的列
    - 包含在order by 、 group by、 distinct 中的字段
    - 多表join的关联列
- 如何选择索引列顺序
    - 从左到右顺序来使用的
    - 区分度最高的列放在联合索引的最左侧
    - 尽量把字段长度小的列放在联合索引的最左侧
    - 使用频繁的列放在联合索引最左侧
- 避免建立冗余索引和重复索引
    - primary(id) index(id) unique index(id) --- 重复了，不要这样使用
    - index(a,b,c) index(a,b) index(a) -- 冗余了
- 对于频繁的查询优先考虑使用覆盖索引
- 尽量避免使用外检

### 4. 数据库字段设计规范

- 优先选择符合存储需要的最小的数据类型
    - 将字符串转换为数字类型存储
        - inet_aton('255.255.255.255') = 4294967295 ip转为数字
        - inet_aton(4294967295) = '255.255.255.255' 数字转ip
    - 对于非负数据采用无符号整型存储
    - varchar(n) n代表字符数，不是字节数（使用utf8存储汉字varchar(255)需要765个字节）
    - 过长的长度会消耗更多内存
- 避免使用TEXT BLOB数据类型
- 避免使用ENUM数据类型
- 尽可能把所有列定义为not null
- 使用timestamp或者datetime类型存储时间
- 同财务相关的金额类数据，必须使用decimal类型

### 5. 数据库SQL开发规范

- 建议使用预编译语句进行数据库操作
- 避免数据类型的隐式转化
- 避免使用双%查询条件
- 禁止使用select *
- 禁止使用不含字段列表的insert语句
- 避免子查询，可以把子查询优化为join操作
- 避免使用join关联太多的表，建议不超过5个表
- 减少同数据库的交互次数
- 使用in代替or(in 可以有效使用索引)
- 禁止使用order by rand()进行随机排序，建议使用程序中获取一个随机值，然后从数据库获取数据
- where从句中禁止对列进行函数转换和计算
- 在明显不会有重复值时使用union all，而不是union
- 拆分复杂的大sql为多个小sql

### 6.数据库操作行为规范

- 超100w行的批量写操作，要分批进行操作
- 对于大表使用 pt-online-schema-change 工具来修改表结构
- 禁止为程序使用的账号赋予super权限
- 对于程序连接数据库账号，遵循权限最小原则

### 7. 数据库设计范式

#### 第三范式

定义： 一个表中的列和其他列之间既不包含部分函数依赖关系，也不包含传递函数依赖关系，那么这个表的设计就符合第三范式

实现： 拆分表以符合第三范式
    
### 8. 常见分区

概念： 逻辑上是一个表，在物理上存储在多个文件

注意： 对于用于主键或者唯一索引的表，主键或者唯一索引必须是分区键的一部分

下面说的字段名 = 分区键。 
#### hash分区

定义： 在创建表的后面增加 
```
    PARTITION BY HASH(字段名) PARTITIONS 分区=数量
``` 

注意： 
- 该字段名必须是int类型值，或者可以通过函数可以转换为int类型值
- 分区数量就是 我们需要分区的数量
- 数据可以平均的分布在各个分区

#### range分区

定义： 在创建表的后面增加
```
    partition by range(字段名)(
        partition p0 values less than (区间1),
        partition p1 values less than (区间2), 
        partition p2 values less than (区间3), 
        partition p3 values less than (区间4),  
        ....
        partition p3 values less than maxvalue
)
```

通过各个区间分为把数据存储到表的不同分区中。

注意：

 - 区间的范围要连续，且不能重复
 - 一般适用于按照时间来分区


#### list分区
    
定义： 在创建表的后面增加
```
    partition by list(字段名)(
        partition p0 values (list分区范围1, 比如 1,3 ,5, 7,9),
        partition p1 values (list分区范围2,4 ,6, 8, 10),`
)
```
list分区类似range分区

注意： 

- 各个分区分为列表不同有重复
- 分区键必须能在分区列表中找到，否则，插入失败。

## 商城表具体设计

详见`https://cloud.tencent.com/developer/article/1164332`
### 用户模块设计 


## mysql执行计划












 



